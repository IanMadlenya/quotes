#!/bin/bash
if test $# -lt 1; then
  echo "Usage: load-opraqte <bz2 input file>"
  exit 1
fi

function bail {
  echo $1
  exit 1
}

# Set the name of the flat file input array:
x=pipe
# Set the opra instruments compound indexing array (kr:optid):
sym=opra_instruments
# Set the name of the consolidated data array:
output=opraqte

echo "This script loads data from $1 into two arrays:"
echo "1. ${output}  data array"
echo "2. ${sym}  unique instrument indexing array"
echo

# Load the required plugins
iquery -naq "load_library('load_tools')" >/dev/null || bail "Missing load_tools plugin"
iquery -naq "load_library('cu')" >/dev/null || bail "Missing cu plugin"
iquery -naq "load_library('superfunpack')" >/dev/null || bail "Missing superfunpack plugin"
iquery -naq "load_library('quote')" >/dev/null || bail "Missing quote type and aggregates"

# Remove the staging input array
iquery -naq "remove($x)" >/dev/null 2>&1

# Number of fields
N=12

# Decompress the input file into a fifo
rm -rf /dev/shm/$x &&  mkfifo /dev/shm/$x
# Fork decompression and add a signal handler to clean up after user interrupt
pbzip2 -d -c $1 | tail -n +2 > /dev/shm/$x &
trap '{ killall -9 %1; exit 1; }' INT

# This is the load query
LOAD="parse(split('/dev/shm/$x','lines_per_chunk=1000000'), 'num_attributes=$N', 'attribute_delimiter=,', 'chunk_size=1000000')"

# This is a custom program for attributes from the opraqte file type.
ATTR="
project(
apply(
apply(
apply(
cast(
$LOAD,
<date: string NULL,
 tkr: string NULL,
 optid: string NULL,
 tm: string NULL,
 _bid: string NULL,
 _bidsz: string NULL,
 _ask: string NULL,
 _asksz: string NULL,
 _exch: string NULL,
 flag: string NULL,
 feed: string NULL,
 _seqnum: string NULL,
 error: string NULL>
[source_instance_id=0:*,1,0,
 chunk_no=0:*,1,0,
 line_no=0:*,1000000,0]
),
day,int64(strpftime(date,'%Y-%m-%d','%s'))),
ms,(int64(strpftime(date + ' ' + tm,'%Y-%m-%d %H:%M:%S','%s'))-day)*1000 + int64(rsub(tm,'s/.*\.//'))),
quote, quote(
       dcast(_bid, float(-1)),
       dcast(_bidsz, int64(-1)),
       dcast(_ask, float(999999999)),
       dcast(_asksz, int64(-1)),
       char(_exch),
       int64(ms)),
exch, int64(char(_exch)),
seqnum, dcast(_seqnum, int64(null))
),
day,ms,tkr,optid,tm,quote,exch,flag,feed,seqnum
)"

echo "Loading flat data file $1 into temporary array $x"
time iquery -naq "store($ATTR, $x)" || exit 1


# -----------------------------------------------------------------------------
# Index the loaded flat file and insert into 4-d array, also enumerate
# unique tkr/optid combinations.

# Munge the ticker and option id into a single instrument_id for indexing.
y="apply($x,instrument,tkr + ':' + string(optid))"
# This table may already exist, if not we create it.
iquery -naq "create_array(${sym}, <instrument:string> [i=0:*,1000000,0])" 2>/dev/null
s="project($y,instrument)"
# This filters out just the new tkr:optid indices, and merges them into the
# instruments table:
idx=$(iquery -ocsv -aq "aggregate(apply(project(${sym},instrument),_,i), max(_))" | tail -n 1)
idx=$(($idx + 1))
s_new="project(filter(index_lookup($s as A, ${sym} as B, A.instrument, instrument_id), is_null(instrument_id)),instrument)"
s_new="uniq(sort(cu($s_new)))"
s_new="cast(redimension(apply($s_new, j, i + $idx),<instrument:string>[j=0:*,1000000,0]),<instrument:string>[i=0:*,1000000,0])"
echo "Merging new instrument indices, here is the number of unique instruments prior to merge:"
iquery -aq "op_count(${sym})"
time iquery -naq "insert($s_new, ${sym})"
echo "Here is the number of unique instruments after merge:"
iquery -aq "op_count(${sym})"

# Append the instrument index to the data array
y="index_lookup($y as A, ${sym} as B, A.instrument, instrument_id)"

# redimension and merge into existing array $output
iquery -naq "create_array($output,
<quote: quote null,
 flag:string null,
 feed:string null,
 seqnum:int64 null>
[synth=0:999,1000,0, exch=0:255, 256, 0, instrument_id=0:*, 2000, 0, day=0:*, 1, 0, ms=0:86399999, 600000, 0])" 2>/dev/null

time iquery -naq "insert(redimension($y, $output), $output)" || exit 1

echo "Done. The $output array now has the following cell count:"
iquery -aq "op_count($output)"
iquery -aq "remove($x)"
